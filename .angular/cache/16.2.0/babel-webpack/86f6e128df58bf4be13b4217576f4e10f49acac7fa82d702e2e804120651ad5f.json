{"ast":null,"code":"var _asyncToGenerator = require(\"/home/asrin/Desktop/global-bilgi/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst {\n  Request,\n  Response\n} = require('minipass-fetch');\nconst {\n  Minipass\n} = require('minipass');\nconst MinipassFlush = require('minipass-flush');\nconst cacache = require('cacache');\nconst url = require('url');\nconst CachingMinipassPipeline = require('../pipeline.js');\nconst CachePolicy = require('./policy.js');\nconst cacheKey = require('./key.js');\nconst remote = require('../remote.js');\nconst hasOwnProperty = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\n\n// allow list for request headers that will be written to the cache index\n// note: we will also store any request headers\n// that are named in a response's vary header\nconst KEEP_REQUEST_HEADERS = ['accept-charset', 'accept-encoding', 'accept-language', 'accept', 'cache-control'];\n\n// allow list for response headers that will be written to the cache index\n// note: we must not store the real response's age header, or when we load\n// a cache policy based on the metadata it will think the cached response\n// is always stale\nconst KEEP_RESPONSE_HEADERS = ['cache-control', 'content-encoding', 'content-language', 'content-type', 'date', 'etag', 'expires', 'last-modified', 'link', 'location', 'pragma', 'vary'];\n\n// return an object containing all metadata to be written to the index\nconst getMetadata = (request, response, options) => {\n  const metadata = {\n    time: Date.now(),\n    url: request.url,\n    reqHeaders: {},\n    resHeaders: {},\n    // options on which we must match the request and vary the response\n    options: {\n      compress: options.compress != null ? options.compress : request.compress\n    }\n  };\n\n  // only save the status if it's not a 200 or 304\n  if (response.status !== 200 && response.status !== 304) {\n    metadata.status = response.status;\n  }\n  for (const name of KEEP_REQUEST_HEADERS) {\n    if (request.headers.has(name)) {\n      metadata.reqHeaders[name] = request.headers.get(name);\n    }\n  }\n\n  // if the request's host header differs from the host in the url\n  // we need to keep it, otherwise it's just noise and we ignore it\n  const host = request.headers.get('host');\n  const parsedUrl = new url.URL(request.url);\n  if (host && parsedUrl.host !== host) {\n    metadata.reqHeaders.host = host;\n  }\n\n  // if the response has a vary header, make sure\n  // we store the relevant request headers too\n  if (response.headers.has('vary')) {\n    const vary = response.headers.get('vary');\n    // a vary of \"*\" means every header causes a different response.\n    // in that scenario, we do not include any additional headers\n    // as the freshness check will always fail anyway and we don't\n    // want to bloat the cache indexes\n    if (vary !== '*') {\n      // copy any other request headers that will vary the response\n      const varyHeaders = vary.trim().toLowerCase().split(/\\s*,\\s*/);\n      for (const name of varyHeaders) {\n        if (request.headers.has(name)) {\n          metadata.reqHeaders[name] = request.headers.get(name);\n        }\n      }\n    }\n  }\n  for (const name of KEEP_RESPONSE_HEADERS) {\n    if (response.headers.has(name)) {\n      metadata.resHeaders[name] = response.headers.get(name);\n    }\n  }\n  for (const name of options.cacheAdditionalHeaders) {\n    if (response.headers.has(name)) {\n      metadata.resHeaders[name] = response.headers.get(name);\n    }\n  }\n  return metadata;\n};\n\n// symbols used to hide objects that may be lazily evaluated in a getter\nconst _request = Symbol('request');\nconst _response = Symbol('response');\nconst _policy = Symbol('policy');\nclass CacheEntry {\n  constructor({\n    entry,\n    request,\n    response,\n    options\n  }) {\n    if (entry) {\n      this.key = entry.key;\n      this.entry = entry;\n      // previous versions of this module didn't write an explicit timestamp in\n      // the metadata, so fall back to the entry's timestamp. we can't use the\n      // entry timestamp to determine staleness because cacache will update it\n      // when it verifies its data\n      this.entry.metadata.time = this.entry.metadata.time || this.entry.time;\n    } else {\n      this.key = cacheKey(request);\n    }\n    this.options = options;\n\n    // these properties are behind getters that lazily evaluate\n    this[_request] = request;\n    this[_response] = response;\n    this[_policy] = null;\n  }\n\n  // returns a CacheEntry instance that satisfies the given request\n  // or undefined if no existing entry satisfies\n  static find(request, options) {\n    return _asyncToGenerator(function* () {\n      try {\n        // compacts the index and returns an array of unique entries\n        var matches = yield cacache.index.compact(options.cachePath, cacheKey(request), (A, B) => {\n          const entryA = new CacheEntry({\n            entry: A,\n            options\n          });\n          const entryB = new CacheEntry({\n            entry: B,\n            options\n          });\n          return entryA.policy.satisfies(entryB.request);\n        }, {\n          validateEntry: entry => {\n            // clean out entries with a buggy content-encoding value\n            if (entry.metadata && entry.metadata.resHeaders && entry.metadata.resHeaders['content-encoding'] === null) {\n              return false;\n            }\n\n            // if an integrity is null, it needs to have a status specified\n            if (entry.integrity === null) {\n              return !!(entry.metadata && entry.metadata.status);\n            }\n            return true;\n          }\n        });\n      } catch (err) {\n        // if the compact request fails, ignore the error and return\n        return;\n      }\n\n      // a cache mode of 'reload' means to behave as though we have no cache\n      // on the way to the network. return undefined to allow cacheFetch to\n      // create a brand new request no matter what.\n      if (options.cache === 'reload') {\n        return;\n      }\n\n      // find the specific entry that satisfies the request\n      let match;\n      for (const entry of matches) {\n        const _entry = new CacheEntry({\n          entry,\n          options\n        });\n        if (_entry.policy.satisfies(request)) {\n          match = _entry;\n          break;\n        }\n      }\n      return match;\n    })();\n  }\n\n  // if the user made a PUT/POST/PATCH then we invalidate our\n  // cache for the same url by deleting the index entirely\n  static invalidate(request, options) {\n    return _asyncToGenerator(function* () {\n      const key = cacheKey(request);\n      try {\n        yield cacache.rm.entry(options.cachePath, key, {\n          removeFully: true\n        });\n      } catch (err) {\n        // ignore errors\n      }\n    })();\n  }\n  get request() {\n    if (!this[_request]) {\n      this[_request] = new Request(this.entry.metadata.url, {\n        method: 'GET',\n        headers: this.entry.metadata.reqHeaders,\n        ...this.entry.metadata.options\n      });\n    }\n    return this[_request];\n  }\n  get response() {\n    if (!this[_response]) {\n      this[_response] = new Response(null, {\n        url: this.entry.metadata.url,\n        counter: this.options.counter,\n        status: this.entry.metadata.status || 200,\n        headers: {\n          ...this.entry.metadata.resHeaders,\n          'content-length': this.entry.size\n        }\n      });\n    }\n    return this[_response];\n  }\n  get policy() {\n    if (!this[_policy]) {\n      this[_policy] = new CachePolicy({\n        entry: this.entry,\n        request: this.request,\n        response: this.response,\n        options: this.options\n      });\n    }\n    return this[_policy];\n  }\n\n  // wraps the response in a pipeline that stores the data\n  // in the cache while the user consumes it\n  store(status) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      // if we got a status other than 200, 301, or 308,\n      // or the CachePolicy forbid storage, append the\n      // cache status header and return it untouched\n      if (_this.request.method !== 'GET' || ![200, 301, 308].includes(_this.response.status) || !_this.policy.storable()) {\n        _this.response.headers.set('x-local-cache-status', 'skip');\n        return _this.response;\n      }\n      const size = _this.response.headers.get('content-length');\n      const cacheOpts = {\n        algorithms: _this.options.algorithms,\n        metadata: getMetadata(_this.request, _this.response, _this.options),\n        size,\n        integrity: _this.options.integrity,\n        integrityEmitter: _this.response.body.hasIntegrityEmitter && _this.response.body\n      };\n      let body = null;\n      // we only set a body if the status is a 200, redirects are\n      // stored as metadata only\n      if (_this.response.status === 200) {\n        let cacheWriteResolve, cacheWriteReject;\n        const cacheWritePromise = new Promise((resolve, reject) => {\n          cacheWriteResolve = resolve;\n          cacheWriteReject = reject;\n        });\n        body = new CachingMinipassPipeline({\n          events: ['integrity', 'size']\n        }, new MinipassFlush({\n          flush() {\n            return cacheWritePromise;\n          }\n        }));\n        // this is always true since if we aren't reusing the one from the remote fetch, we\n        // are using the one from cacache\n        body.hasIntegrityEmitter = true;\n        const onResume = () => {\n          const tee = new Minipass();\n          const cacheStream = cacache.put.stream(_this.options.cachePath, _this.key, cacheOpts);\n          // re-emit the integrity and size events on our new response body so they can be reused\n          cacheStream.on('integrity', i => body.emit('integrity', i));\n          cacheStream.on('size', s => body.emit('size', s));\n          // stick a flag on here so downstream users will know if they can expect integrity events\n          tee.pipe(cacheStream);\n          // TODO if the cache write fails, log a warning but return the response anyway\n          // eslint-disable-next-line promise/catch-or-return\n          cacheStream.promise().then(cacheWriteResolve, cacheWriteReject);\n          body.unshift(tee);\n          body.unshift(_this.response.body);\n        };\n        body.once('resume', onResume);\n        body.once('end', () => body.removeListener('resume', onResume));\n      } else {\n        yield cacache.index.insert(_this.options.cachePath, _this.key, null, cacheOpts);\n      }\n\n      // note: we do not set the x-local-cache-hash header because we do not know\n      // the hash value until after the write to the cache completes, which doesn't\n      // happen until after the response has been sent and it's too late to write\n      // the header anyway\n      _this.response.headers.set('x-local-cache', encodeURIComponent(_this.options.cachePath));\n      _this.response.headers.set('x-local-cache-key', encodeURIComponent(_this.key));\n      _this.response.headers.set('x-local-cache-mode', 'stream');\n      _this.response.headers.set('x-local-cache-status', status);\n      _this.response.headers.set('x-local-cache-time', new Date().toISOString());\n      const newResponse = new Response(body, {\n        url: _this.response.url,\n        status: _this.response.status,\n        headers: _this.response.headers,\n        counter: _this.options.counter\n      });\n      return newResponse;\n    })();\n  }\n\n  // use the cached data to create a response and return it\n  respond(method, options, status) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      let response;\n      if (method === 'HEAD' || [301, 308].includes(_this2.response.status)) {\n        // if the request is a HEAD, or the response is a redirect,\n        // then the metadata in the entry already includes everything\n        // we need to build a response\n        response = _this2.response;\n      } else {\n        // we're responding with a full cached response, so create a body\n        // that reads from cacache and attach it to a new Response\n        const body = new Minipass();\n        const headers = {\n          ..._this2.policy.responseHeaders()\n        };\n        const onResume = () => {\n          const cacheStream = cacache.get.stream.byDigest(_this2.options.cachePath, _this2.entry.integrity, {\n            memoize: _this2.options.memoize\n          });\n          cacheStream.on('error', /*#__PURE__*/function () {\n            var _ref = _asyncToGenerator(function* (err) {\n              cacheStream.pause();\n              if (err.code === 'EINTEGRITY') {\n                yield cacache.rm.content(_this2.options.cachePath, _this2.entry.integrity, {\n                  memoize: _this2.options.memoize\n                });\n              }\n              if (err.code === 'ENOENT' || err.code === 'EINTEGRITY') {\n                yield CacheEntry.invalidate(_this2.request, _this2.options);\n              }\n              body.emit('error', err);\n              cacheStream.resume();\n            });\n            return function (_x) {\n              return _ref.apply(this, arguments);\n            };\n          }());\n          // emit the integrity and size events based on our metadata so we're consistent\n          body.emit('integrity', _this2.entry.integrity);\n          body.emit('size', Number(headers['content-length']));\n          cacheStream.pipe(body);\n        };\n        body.once('resume', onResume);\n        body.once('end', () => body.removeListener('resume', onResume));\n        response = new Response(body, {\n          url: _this2.entry.metadata.url,\n          counter: options.counter,\n          status: 200,\n          headers\n        });\n      }\n      response.headers.set('x-local-cache', encodeURIComponent(_this2.options.cachePath));\n      response.headers.set('x-local-cache-hash', encodeURIComponent(_this2.entry.integrity));\n      response.headers.set('x-local-cache-key', encodeURIComponent(_this2.key));\n      response.headers.set('x-local-cache-mode', 'stream');\n      response.headers.set('x-local-cache-status', status);\n      response.headers.set('x-local-cache-time', new Date(_this2.entry.metadata.time).toUTCString());\n      return response;\n    })();\n  }\n\n  // use the provided request along with this cache entry to\n  // revalidate the stored response. returns a response, either\n  // from the cache or from the update\n  revalidate(request, options) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const revalidateRequest = new Request(request, {\n        headers: _this3.policy.revalidationHeaders(request)\n      });\n      try {\n        // NOTE: be sure to remove the headers property from the\n        // user supplied options, since we have already defined\n        // them on the new request object. if they're still in the\n        // options then those will overwrite the ones from the policy\n        var response = yield remote(revalidateRequest, {\n          ...options,\n          headers: undefined\n        });\n      } catch (err) {\n        // if the network fetch fails, return the stale\n        // cached response unless it has a cache-control\n        // of 'must-revalidate'\n        if (!_this3.policy.mustRevalidate) {\n          return _this3.respond(request.method, options, 'stale');\n        }\n        throw err;\n      }\n      if (_this3.policy.revalidated(revalidateRequest, response)) {\n        // we got a 304, write a new index to the cache and respond from cache\n        const metadata = getMetadata(request, response, options);\n        // 304 responses do not include headers that are specific to the response data\n        // since they do not include a body, so we copy values for headers that were\n        // in the old cache entry to the new one, if the new metadata does not already\n        // include that header\n        for (const name of KEEP_RESPONSE_HEADERS) {\n          if (!hasOwnProperty(metadata.resHeaders, name) && hasOwnProperty(_this3.entry.metadata.resHeaders, name)) {\n            metadata.resHeaders[name] = _this3.entry.metadata.resHeaders[name];\n          }\n        }\n        for (const name of options.cacheAdditionalHeaders) {\n          const inMeta = hasOwnProperty(metadata.resHeaders, name);\n          const inEntry = hasOwnProperty(_this3.entry.metadata.resHeaders, name);\n          const inPolicy = hasOwnProperty(_this3.policy.response.headers, name);\n\n          // if the header is in the existing entry, but it is not in the metadata\n          // then we need to write it to the metadata as this will refresh the on-disk cache\n          if (!inMeta && inEntry) {\n            metadata.resHeaders[name] = _this3.entry.metadata.resHeaders[name];\n          }\n          // if the header is in the metadata, but not in the policy, then we need to set\n          // it in the policy so that it's included in the immediate response. future\n          // responses will load a new cache entry, so we don't need to change that\n          if (!inPolicy && inMeta) {\n            _this3.policy.response.headers[name] = metadata.resHeaders[name];\n          }\n        }\n        try {\n          yield cacache.index.insert(options.cachePath, _this3.key, _this3.entry.integrity, {\n            size: _this3.entry.size,\n            metadata\n          });\n        } catch (err) {\n          // if updating the cache index fails, we ignore it and\n          // respond anyway\n        }\n        return _this3.respond(request.method, options, 'revalidated');\n      }\n\n      // if we got a modified response, create a new entry based on it\n      const newEntry = new CacheEntry({\n        request,\n        response,\n        options\n      });\n\n      // respond with the new entry while writing it to the cache\n      return newEntry.store('updated');\n    })();\n  }\n}\nmodule.exports = CacheEntry;","map":{"version":3,"names":["Request","Response","require","Minipass","MinipassFlush","cacache","url","CachingMinipassPipeline","CachePolicy","cacheKey","remote","hasOwnProperty","obj","prop","Object","prototype","call","KEEP_REQUEST_HEADERS","KEEP_RESPONSE_HEADERS","getMetadata","request","response","options","metadata","time","Date","now","reqHeaders","resHeaders","compress","status","name","headers","has","get","host","parsedUrl","URL","vary","varyHeaders","trim","toLowerCase","split","cacheAdditionalHeaders","_request","Symbol","_response","_policy","CacheEntry","constructor","entry","key","find","_asyncToGenerator","matches","index","compact","cachePath","A","B","entryA","entryB","policy","satisfies","validateEntry","integrity","err","cache","match","_entry","invalidate","rm","removeFully","method","counter","size","store","_this","includes","storable","set","cacheOpts","algorithms","integrityEmitter","body","hasIntegrityEmitter","cacheWriteResolve","cacheWriteReject","cacheWritePromise","Promise","resolve","reject","events","flush","onResume","tee","cacheStream","put","stream","on","i","emit","s","pipe","promise","then","unshift","once","removeListener","insert","encodeURIComponent","toISOString","newResponse","respond","_this2","responseHeaders","byDigest","memoize","_ref","pause","code","content","resume","_x","apply","arguments","Number","toUTCString","revalidate","_this3","revalidateRequest","revalidationHeaders","undefined","mustRevalidate","revalidated","inMeta","inEntry","inPolicy","newEntry","module","exports"],"sources":["/home/asrin/Desktop/global-bilgi/node_modules/make-fetch-happen/lib/cache/entry.js"],"sourcesContent":["const { Request, Response } = require('minipass-fetch')\nconst { Minipass } = require('minipass')\nconst MinipassFlush = require('minipass-flush')\nconst cacache = require('cacache')\nconst url = require('url')\n\nconst CachingMinipassPipeline = require('../pipeline.js')\nconst CachePolicy = require('./policy.js')\nconst cacheKey = require('./key.js')\nconst remote = require('../remote.js')\n\nconst hasOwnProperty = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)\n\n// allow list for request headers that will be written to the cache index\n// note: we will also store any request headers\n// that are named in a response's vary header\nconst KEEP_REQUEST_HEADERS = [\n  'accept-charset',\n  'accept-encoding',\n  'accept-language',\n  'accept',\n  'cache-control',\n]\n\n// allow list for response headers that will be written to the cache index\n// note: we must not store the real response's age header, or when we load\n// a cache policy based on the metadata it will think the cached response\n// is always stale\nconst KEEP_RESPONSE_HEADERS = [\n  'cache-control',\n  'content-encoding',\n  'content-language',\n  'content-type',\n  'date',\n  'etag',\n  'expires',\n  'last-modified',\n  'link',\n  'location',\n  'pragma',\n  'vary',\n]\n\n// return an object containing all metadata to be written to the index\nconst getMetadata = (request, response, options) => {\n  const metadata = {\n    time: Date.now(),\n    url: request.url,\n    reqHeaders: {},\n    resHeaders: {},\n\n    // options on which we must match the request and vary the response\n    options: {\n      compress: options.compress != null ? options.compress : request.compress,\n    },\n  }\n\n  // only save the status if it's not a 200 or 304\n  if (response.status !== 200 && response.status !== 304) {\n    metadata.status = response.status\n  }\n\n  for (const name of KEEP_REQUEST_HEADERS) {\n    if (request.headers.has(name)) {\n      metadata.reqHeaders[name] = request.headers.get(name)\n    }\n  }\n\n  // if the request's host header differs from the host in the url\n  // we need to keep it, otherwise it's just noise and we ignore it\n  const host = request.headers.get('host')\n  const parsedUrl = new url.URL(request.url)\n  if (host && parsedUrl.host !== host) {\n    metadata.reqHeaders.host = host\n  }\n\n  // if the response has a vary header, make sure\n  // we store the relevant request headers too\n  if (response.headers.has('vary')) {\n    const vary = response.headers.get('vary')\n    // a vary of \"*\" means every header causes a different response.\n    // in that scenario, we do not include any additional headers\n    // as the freshness check will always fail anyway and we don't\n    // want to bloat the cache indexes\n    if (vary !== '*') {\n      // copy any other request headers that will vary the response\n      const varyHeaders = vary.trim().toLowerCase().split(/\\s*,\\s*/)\n      for (const name of varyHeaders) {\n        if (request.headers.has(name)) {\n          metadata.reqHeaders[name] = request.headers.get(name)\n        }\n      }\n    }\n  }\n\n  for (const name of KEEP_RESPONSE_HEADERS) {\n    if (response.headers.has(name)) {\n      metadata.resHeaders[name] = response.headers.get(name)\n    }\n  }\n\n  for (const name of options.cacheAdditionalHeaders) {\n    if (response.headers.has(name)) {\n      metadata.resHeaders[name] = response.headers.get(name)\n    }\n  }\n\n  return metadata\n}\n\n// symbols used to hide objects that may be lazily evaluated in a getter\nconst _request = Symbol('request')\nconst _response = Symbol('response')\nconst _policy = Symbol('policy')\n\nclass CacheEntry {\n  constructor ({ entry, request, response, options }) {\n    if (entry) {\n      this.key = entry.key\n      this.entry = entry\n      // previous versions of this module didn't write an explicit timestamp in\n      // the metadata, so fall back to the entry's timestamp. we can't use the\n      // entry timestamp to determine staleness because cacache will update it\n      // when it verifies its data\n      this.entry.metadata.time = this.entry.metadata.time || this.entry.time\n    } else {\n      this.key = cacheKey(request)\n    }\n\n    this.options = options\n\n    // these properties are behind getters that lazily evaluate\n    this[_request] = request\n    this[_response] = response\n    this[_policy] = null\n  }\n\n  // returns a CacheEntry instance that satisfies the given request\n  // or undefined if no existing entry satisfies\n  static async find (request, options) {\n    try {\n      // compacts the index and returns an array of unique entries\n      var matches = await cacache.index.compact(options.cachePath, cacheKey(request), (A, B) => {\n        const entryA = new CacheEntry({ entry: A, options })\n        const entryB = new CacheEntry({ entry: B, options })\n        return entryA.policy.satisfies(entryB.request)\n      }, {\n        validateEntry: (entry) => {\n          // clean out entries with a buggy content-encoding value\n          if (entry.metadata &&\n              entry.metadata.resHeaders &&\n              entry.metadata.resHeaders['content-encoding'] === null) {\n            return false\n          }\n\n          // if an integrity is null, it needs to have a status specified\n          if (entry.integrity === null) {\n            return !!(entry.metadata && entry.metadata.status)\n          }\n\n          return true\n        },\n      })\n    } catch (err) {\n      // if the compact request fails, ignore the error and return\n      return\n    }\n\n    // a cache mode of 'reload' means to behave as though we have no cache\n    // on the way to the network. return undefined to allow cacheFetch to\n    // create a brand new request no matter what.\n    if (options.cache === 'reload') {\n      return\n    }\n\n    // find the specific entry that satisfies the request\n    let match\n    for (const entry of matches) {\n      const _entry = new CacheEntry({\n        entry,\n        options,\n      })\n\n      if (_entry.policy.satisfies(request)) {\n        match = _entry\n        break\n      }\n    }\n\n    return match\n  }\n\n  // if the user made a PUT/POST/PATCH then we invalidate our\n  // cache for the same url by deleting the index entirely\n  static async invalidate (request, options) {\n    const key = cacheKey(request)\n    try {\n      await cacache.rm.entry(options.cachePath, key, { removeFully: true })\n    } catch (err) {\n      // ignore errors\n    }\n  }\n\n  get request () {\n    if (!this[_request]) {\n      this[_request] = new Request(this.entry.metadata.url, {\n        method: 'GET',\n        headers: this.entry.metadata.reqHeaders,\n        ...this.entry.metadata.options,\n      })\n    }\n\n    return this[_request]\n  }\n\n  get response () {\n    if (!this[_response]) {\n      this[_response] = new Response(null, {\n        url: this.entry.metadata.url,\n        counter: this.options.counter,\n        status: this.entry.metadata.status || 200,\n        headers: {\n          ...this.entry.metadata.resHeaders,\n          'content-length': this.entry.size,\n        },\n      })\n    }\n\n    return this[_response]\n  }\n\n  get policy () {\n    if (!this[_policy]) {\n      this[_policy] = new CachePolicy({\n        entry: this.entry,\n        request: this.request,\n        response: this.response,\n        options: this.options,\n      })\n    }\n\n    return this[_policy]\n  }\n\n  // wraps the response in a pipeline that stores the data\n  // in the cache while the user consumes it\n  async store (status) {\n    // if we got a status other than 200, 301, or 308,\n    // or the CachePolicy forbid storage, append the\n    // cache status header and return it untouched\n    if (\n      this.request.method !== 'GET' ||\n      ![200, 301, 308].includes(this.response.status) ||\n      !this.policy.storable()\n    ) {\n      this.response.headers.set('x-local-cache-status', 'skip')\n      return this.response\n    }\n\n    const size = this.response.headers.get('content-length')\n    const cacheOpts = {\n      algorithms: this.options.algorithms,\n      metadata: getMetadata(this.request, this.response, this.options),\n      size,\n      integrity: this.options.integrity,\n      integrityEmitter: this.response.body.hasIntegrityEmitter && this.response.body,\n    }\n\n    let body = null\n    // we only set a body if the status is a 200, redirects are\n    // stored as metadata only\n    if (this.response.status === 200) {\n      let cacheWriteResolve, cacheWriteReject\n      const cacheWritePromise = new Promise((resolve, reject) => {\n        cacheWriteResolve = resolve\n        cacheWriteReject = reject\n      })\n\n      body = new CachingMinipassPipeline({ events: ['integrity', 'size'] }, new MinipassFlush({\n        flush () {\n          return cacheWritePromise\n        },\n      }))\n      // this is always true since if we aren't reusing the one from the remote fetch, we\n      // are using the one from cacache\n      body.hasIntegrityEmitter = true\n\n      const onResume = () => {\n        const tee = new Minipass()\n        const cacheStream = cacache.put.stream(this.options.cachePath, this.key, cacheOpts)\n        // re-emit the integrity and size events on our new response body so they can be reused\n        cacheStream.on('integrity', i => body.emit('integrity', i))\n        cacheStream.on('size', s => body.emit('size', s))\n        // stick a flag on here so downstream users will know if they can expect integrity events\n        tee.pipe(cacheStream)\n        // TODO if the cache write fails, log a warning but return the response anyway\n        // eslint-disable-next-line promise/catch-or-return\n        cacheStream.promise().then(cacheWriteResolve, cacheWriteReject)\n        body.unshift(tee)\n        body.unshift(this.response.body)\n      }\n\n      body.once('resume', onResume)\n      body.once('end', () => body.removeListener('resume', onResume))\n    } else {\n      await cacache.index.insert(this.options.cachePath, this.key, null, cacheOpts)\n    }\n\n    // note: we do not set the x-local-cache-hash header because we do not know\n    // the hash value until after the write to the cache completes, which doesn't\n    // happen until after the response has been sent and it's too late to write\n    // the header anyway\n    this.response.headers.set('x-local-cache', encodeURIComponent(this.options.cachePath))\n    this.response.headers.set('x-local-cache-key', encodeURIComponent(this.key))\n    this.response.headers.set('x-local-cache-mode', 'stream')\n    this.response.headers.set('x-local-cache-status', status)\n    this.response.headers.set('x-local-cache-time', new Date().toISOString())\n    const newResponse = new Response(body, {\n      url: this.response.url,\n      status: this.response.status,\n      headers: this.response.headers,\n      counter: this.options.counter,\n    })\n    return newResponse\n  }\n\n  // use the cached data to create a response and return it\n  async respond (method, options, status) {\n    let response\n    if (method === 'HEAD' || [301, 308].includes(this.response.status)) {\n      // if the request is a HEAD, or the response is a redirect,\n      // then the metadata in the entry already includes everything\n      // we need to build a response\n      response = this.response\n    } else {\n      // we're responding with a full cached response, so create a body\n      // that reads from cacache and attach it to a new Response\n      const body = new Minipass()\n      const headers = { ...this.policy.responseHeaders() }\n\n      const onResume = () => {\n        const cacheStream = cacache.get.stream.byDigest(\n          this.options.cachePath, this.entry.integrity, { memoize: this.options.memoize }\n        )\n        cacheStream.on('error', async (err) => {\n          cacheStream.pause()\n          if (err.code === 'EINTEGRITY') {\n            await cacache.rm.content(\n              this.options.cachePath, this.entry.integrity, { memoize: this.options.memoize }\n            )\n          }\n          if (err.code === 'ENOENT' || err.code === 'EINTEGRITY') {\n            await CacheEntry.invalidate(this.request, this.options)\n          }\n          body.emit('error', err)\n          cacheStream.resume()\n        })\n        // emit the integrity and size events based on our metadata so we're consistent\n        body.emit('integrity', this.entry.integrity)\n        body.emit('size', Number(headers['content-length']))\n        cacheStream.pipe(body)\n      }\n\n      body.once('resume', onResume)\n      body.once('end', () => body.removeListener('resume', onResume))\n      response = new Response(body, {\n        url: this.entry.metadata.url,\n        counter: options.counter,\n        status: 200,\n        headers,\n      })\n    }\n\n    response.headers.set('x-local-cache', encodeURIComponent(this.options.cachePath))\n    response.headers.set('x-local-cache-hash', encodeURIComponent(this.entry.integrity))\n    response.headers.set('x-local-cache-key', encodeURIComponent(this.key))\n    response.headers.set('x-local-cache-mode', 'stream')\n    response.headers.set('x-local-cache-status', status)\n    response.headers.set('x-local-cache-time', new Date(this.entry.metadata.time).toUTCString())\n    return response\n  }\n\n  // use the provided request along with this cache entry to\n  // revalidate the stored response. returns a response, either\n  // from the cache or from the update\n  async revalidate (request, options) {\n    const revalidateRequest = new Request(request, {\n      headers: this.policy.revalidationHeaders(request),\n    })\n\n    try {\n      // NOTE: be sure to remove the headers property from the\n      // user supplied options, since we have already defined\n      // them on the new request object. if they're still in the\n      // options then those will overwrite the ones from the policy\n      var response = await remote(revalidateRequest, {\n        ...options,\n        headers: undefined,\n      })\n    } catch (err) {\n      // if the network fetch fails, return the stale\n      // cached response unless it has a cache-control\n      // of 'must-revalidate'\n      if (!this.policy.mustRevalidate) {\n        return this.respond(request.method, options, 'stale')\n      }\n\n      throw err\n    }\n\n    if (this.policy.revalidated(revalidateRequest, response)) {\n      // we got a 304, write a new index to the cache and respond from cache\n      const metadata = getMetadata(request, response, options)\n      // 304 responses do not include headers that are specific to the response data\n      // since they do not include a body, so we copy values for headers that were\n      // in the old cache entry to the new one, if the new metadata does not already\n      // include that header\n      for (const name of KEEP_RESPONSE_HEADERS) {\n        if (\n          !hasOwnProperty(metadata.resHeaders, name) &&\n          hasOwnProperty(this.entry.metadata.resHeaders, name)\n        ) {\n          metadata.resHeaders[name] = this.entry.metadata.resHeaders[name]\n        }\n      }\n\n      for (const name of options.cacheAdditionalHeaders) {\n        const inMeta = hasOwnProperty(metadata.resHeaders, name)\n        const inEntry = hasOwnProperty(this.entry.metadata.resHeaders, name)\n        const inPolicy = hasOwnProperty(this.policy.response.headers, name)\n\n        // if the header is in the existing entry, but it is not in the metadata\n        // then we need to write it to the metadata as this will refresh the on-disk cache\n        if (!inMeta && inEntry) {\n          metadata.resHeaders[name] = this.entry.metadata.resHeaders[name]\n        }\n        // if the header is in the metadata, but not in the policy, then we need to set\n        // it in the policy so that it's included in the immediate response. future\n        // responses will load a new cache entry, so we don't need to change that\n        if (!inPolicy && inMeta) {\n          this.policy.response.headers[name] = metadata.resHeaders[name]\n        }\n      }\n\n      try {\n        await cacache.index.insert(options.cachePath, this.key, this.entry.integrity, {\n          size: this.entry.size,\n          metadata,\n        })\n      } catch (err) {\n        // if updating the cache index fails, we ignore it and\n        // respond anyway\n      }\n      return this.respond(request.method, options, 'revalidated')\n    }\n\n    // if we got a modified response, create a new entry based on it\n    const newEntry = new CacheEntry({\n      request,\n      response,\n      options,\n    })\n\n    // respond with the new entry while writing it to the cache\n    return newEntry.store('updated')\n  }\n}\n\nmodule.exports = CacheEntry\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}