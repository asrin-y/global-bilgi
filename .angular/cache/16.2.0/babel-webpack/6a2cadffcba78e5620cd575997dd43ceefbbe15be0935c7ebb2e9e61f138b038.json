{"ast":null,"code":"\"use strict\";\n\n// give it a pattern, and it'll be able to tell you if\n// a given path should be ignored.\n// Ignoring a path ignores its children if the pattern ends in /**\n// Ignores are always parsed in dot:true mode\nvar _defineProperty = require(\"/home/asrin/Desktop/global-bilgi/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Ignore = void 0;\nconst minimatch_1 = require(\"minimatch\");\nconst pattern_js_1 = require(\"./pattern.js\");\nconst defaultPlatform = typeof process === 'object' && process && typeof process.platform === 'string' ? process.platform : 'linux';\n/**\n * Class used to process ignored patterns\n */\nclass Ignore {\n  constructor(ignored, {\n    nobrace,\n    nocase,\n    noext,\n    noglobstar,\n    platform = defaultPlatform\n  }) {\n    _defineProperty(this, \"relative\", void 0);\n    _defineProperty(this, \"relativeChildren\", void 0);\n    _defineProperty(this, \"absolute\", void 0);\n    _defineProperty(this, \"absoluteChildren\", void 0);\n    this.relative = [];\n    this.absolute = [];\n    this.relativeChildren = [];\n    this.absoluteChildren = [];\n    const mmopts = {\n      dot: true,\n      nobrace,\n      nocase,\n      noext,\n      noglobstar,\n      optimizationLevel: 2,\n      platform,\n      nocomment: true,\n      nonegate: true\n    };\n    // this is a little weird, but it gives us a clean set of optimized\n    // minimatch matchers, without getting tripped up if one of them\n    // ends in /** inside a brace section, and it's only inefficient at\n    // the start of the walk, not along it.\n    // It'd be nice if the Pattern class just had a .test() method, but\n    // handling globstars is a bit of a pita, and that code already lives\n    // in minimatch anyway.\n    // Another way would be if maybe Minimatch could take its set/globParts\n    // as an option, and then we could at least just use Pattern to test\n    // for absolute-ness.\n    // Yet another way, Minimatch could take an array of glob strings, and\n    // a cwd option, and do the right thing.\n    for (const ign of ignored) {\n      const mm = new minimatch_1.Minimatch(ign, mmopts);\n      for (let i = 0; i < mm.set.length; i++) {\n        const parsed = mm.set[i];\n        const globParts = mm.globParts[i];\n        const p = new pattern_js_1.Pattern(parsed, globParts, 0, platform);\n        const m = new minimatch_1.Minimatch(p.globString(), mmopts);\n        const children = globParts[globParts.length - 1] === '**';\n        const absolute = p.isAbsolute();\n        if (absolute) this.absolute.push(m);else this.relative.push(m);\n        if (children) {\n          if (absolute) this.absoluteChildren.push(m);else this.relativeChildren.push(m);\n        }\n      }\n    }\n  }\n  ignored(p) {\n    const fullpath = p.fullpath();\n    const fullpaths = `${fullpath}/`;\n    const relative = p.relative() || '.';\n    const relatives = `${relative}/`;\n    for (const m of this.relative) {\n      if (m.match(relative) || m.match(relatives)) return true;\n    }\n    for (const m of this.absolute) {\n      if (m.match(fullpath) || m.match(fullpaths)) return true;\n    }\n    return false;\n  }\n  childrenIgnored(p) {\n    const fullpath = p.fullpath() + '/';\n    const relative = (p.relative() || '.') + '/';\n    for (const m of this.relativeChildren) {\n      if (m.match(relative)) return true;\n    }\n    for (const m of this.absoluteChildren) {\n      if (m.match(fullpath)) true;\n    }\n    return false;\n  }\n}\nexports.Ignore = Ignore;","map":{"version":3,"names":["_defineProperty","require","default","Object","defineProperty","exports","value","Ignore","minimatch_1","pattern_js_1","defaultPlatform","process","platform","constructor","ignored","nobrace","nocase","noext","noglobstar","relative","absolute","relativeChildren","absoluteChildren","mmopts","dot","optimizationLevel","nocomment","nonegate","ign","mm","Minimatch","i","set","length","parsed","globParts","p","Pattern","m","globString","children","isAbsolute","push","fullpath","fullpaths","relatives","match","childrenIgnored"],"sources":["/home/asrin/Desktop/global-bilgi/node_modules/cacache/node_modules/glob/dist/cjs/src/ignore.js"],"sourcesContent":["\"use strict\";\n// give it a pattern, and it'll be able to tell you if\n// a given path should be ignored.\n// Ignoring a path ignores its children if the pattern ends in /**\n// Ignores are always parsed in dot:true mode\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Ignore = void 0;\nconst minimatch_1 = require(\"minimatch\");\nconst pattern_js_1 = require(\"./pattern.js\");\nconst defaultPlatform = typeof process === 'object' &&\n    process &&\n    typeof process.platform === 'string'\n    ? process.platform\n    : 'linux';\n/**\n * Class used to process ignored patterns\n */\nclass Ignore {\n    relative;\n    relativeChildren;\n    absolute;\n    absoluteChildren;\n    constructor(ignored, { nobrace, nocase, noext, noglobstar, platform = defaultPlatform, }) {\n        this.relative = [];\n        this.absolute = [];\n        this.relativeChildren = [];\n        this.absoluteChildren = [];\n        const mmopts = {\n            dot: true,\n            nobrace,\n            nocase,\n            noext,\n            noglobstar,\n            optimizationLevel: 2,\n            platform,\n            nocomment: true,\n            nonegate: true,\n        };\n        // this is a little weird, but it gives us a clean set of optimized\n        // minimatch matchers, without getting tripped up if one of them\n        // ends in /** inside a brace section, and it's only inefficient at\n        // the start of the walk, not along it.\n        // It'd be nice if the Pattern class just had a .test() method, but\n        // handling globstars is a bit of a pita, and that code already lives\n        // in minimatch anyway.\n        // Another way would be if maybe Minimatch could take its set/globParts\n        // as an option, and then we could at least just use Pattern to test\n        // for absolute-ness.\n        // Yet another way, Minimatch could take an array of glob strings, and\n        // a cwd option, and do the right thing.\n        for (const ign of ignored) {\n            const mm = new minimatch_1.Minimatch(ign, mmopts);\n            for (let i = 0; i < mm.set.length; i++) {\n                const parsed = mm.set[i];\n                const globParts = mm.globParts[i];\n                const p = new pattern_js_1.Pattern(parsed, globParts, 0, platform);\n                const m = new minimatch_1.Minimatch(p.globString(), mmopts);\n                const children = globParts[globParts.length - 1] === '**';\n                const absolute = p.isAbsolute();\n                if (absolute)\n                    this.absolute.push(m);\n                else\n                    this.relative.push(m);\n                if (children) {\n                    if (absolute)\n                        this.absoluteChildren.push(m);\n                    else\n                        this.relativeChildren.push(m);\n                }\n            }\n        }\n    }\n    ignored(p) {\n        const fullpath = p.fullpath();\n        const fullpaths = `${fullpath}/`;\n        const relative = p.relative() || '.';\n        const relatives = `${relative}/`;\n        for (const m of this.relative) {\n            if (m.match(relative) || m.match(relatives))\n                return true;\n        }\n        for (const m of this.absolute) {\n            if (m.match(fullpath) || m.match(fullpaths))\n                return true;\n        }\n        return false;\n    }\n    childrenIgnored(p) {\n        const fullpath = p.fullpath() + '/';\n        const relative = (p.relative() || '.') + '/';\n        for (const m of this.relativeChildren) {\n            if (m.match(relative))\n                return true;\n        }\n        for (const m of this.absoluteChildren) {\n            if (m.match(fullpath))\n                true;\n        }\n        return false;\n    }\n}\nexports.Ignore = Ignore;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}